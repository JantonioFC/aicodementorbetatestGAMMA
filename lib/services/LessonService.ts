import { logger } from '../observability/Logger';
import { geminiRouter } from '../ai/router/GeminiRouter';
import { AnalysisAnalysis, AnalysisResponse } from '../ai/providers/BaseProvider';
import { buildLessonPromptMessages, LessonContext } from '../prompts/LessonPrompts';

// --- Interfaces de Dominio ---

export interface QuizQuestion {
    question: string;
    options: string[];
    correctAnswer: string;
    explanation?: string;
}

export interface PracticalExercise {
    title: string;
    description: string;
    startingCode?: string;
    expectedOutput?: string;
    hints?: string[];
}

export interface LessonRequest {
    topic: string;
    difficulty: string;
    userId?: string;
    language?: string;
    context?: LessonContext; // Contexto específico para el prompt
    injectedContext?: string[]; // Contexto RAG inyectado
    metadata?: Record<string, unknown>;
}

export interface LessonContent {
    id: string;
    title: string;
    content: string; // Markdown generated by AI
    difficulty: string;
    language: string;
    quiz?: QuizQuestion[]; // Quizzes generated by AI
    exercises?: PracticalExercise[]; // Interactive exercises
    metadata: {
        engine: string;
        model: string;
        generated_at: string;
        tokens_used?: number;
        latency?: number;
        [key: string]: unknown;
    };
    raw_analysis?: AnalysisAnalysis; // Optional detailed analysis
}


export class LessonService {

    /**
     * Genera una lección educativa utilizando IA.
     * Conecta directamente con GeminiRouter para orquestación de modelos.
     */
    async generateLesson(params: LessonRequest): Promise<LessonContent> {
        logger.info(`[LessonService] Pipeline Started: ${params.topic}`);

        const initialContext: PipelineContext = {
            request: params,
            timestamp: Date.now()
        };

        const ctx1 = await this._validateContext(initialContext);
        const ctx2 = await this._generateAIContent(ctx1);
        const result = await this._structureOutput(ctx2);

        if (!result.lesson) {
            throw new Error('Failed to generate lesson content');
        }

        return result.lesson;
    }

    // --- Functional Stages ---

    private _validateContext = async (ctx: PipelineContext): Promise<PipelineContext> => {
        if (!ctx.request.topic) throw new Error('Topic is required');
        return ctx;
    }

    private _generateAIContent = async (ctx: PipelineContext): Promise<PipelineContext> => {
        const { topic, difficulty, language, injectedContext, context } = ctx.request;
        const lang = language || 'es';

        // 1. Construir Prompts
        const lessonContext: LessonContext = {
            tematica_semanal: topic,
            concepto_del_dia: `Nivel ${difficulty}`,
            texto_del_pomodoro: injectedContext ? injectedContext.join('\n\n') : undefined,
            ...context // Merge extra context
        };

        const rawMessages = buildLessonPromptMessages(lessonContext);

        // Map to AnalysisRequest format
        let systemPrompt = '';
        const mappedMessages: Array<{ role: 'user' | 'model'; content: string }> = [];

        for (const msg of rawMessages) {
            if (msg.role === 'system') {
                systemPrompt += msg.content + '\n';
            } else {
                mappedMessages.push({
                    role: msg.role === 'assistant' ? 'model' : 'user',
                    content: msg.content
                });
            }
        }

        // 2. Llamar a GeminiRouter
        try {
            const response = await geminiRouter.analyze({
                code: '', // No code for lesson generation
                language: lang,
                phase: 'fase-1', // Default educational phase
                systemPrompt: systemPrompt.trim(),
                messages: mappedMessages,
                analysisType: 'lesson_generation'
            });

            return {
                ...ctx,
                aiResponse: response
            };

        } catch (error: unknown) {
            logger.error(`[LessonService] AI Generation failed: ${error instanceof Error ? error.message : String(error)}`);
            throw error;
        }
    }

    private _structureOutput = async (ctx: PipelineContext): Promise<PipelineContext> => {
        if (!ctx.aiResponse) {
            throw new Error('No AI response available to structure');
        }

        const { request, aiResponse, timestamp } = ctx;
        const analysis = aiResponse.analysis;

        const contentBody = String(analysis.feedback || analysis.content || JSON.stringify(analysis));
        const quiz = (analysis.quiz || analysis.quiz_questions || []) as QuizQuestion[];
        const exercises = (analysis.exercises || analysis.practical_exercises || []) as PracticalExercise[];

        const lesson: LessonContent = {
            id: `gen-${timestamp}`,
            title: `Lección experta: ${request.topic}`,
            content: contentBody,
            difficulty: request.difficulty,
            language: request.language || 'es',
            quiz,
            exercises,
            metadata: {
                engine: 'v4-gemini-router',
                model: aiResponse.metadata.model,
                generated_at: new Date().toISOString(),
                tokens_used: aiResponse.metadata.tokensUsed,
                latency: aiResponse.metadata.latency,
                ...request.metadata
            },
            raw_analysis: analysis
        };

        return {
            ...ctx,
            lesson
        };
    }
}

// Internal Interface for the Pipeline Flow
interface PipelineContext {
    request: LessonRequest;
    timestamp: number;
    aiResponse?: AnalysisResponse;
    lesson?: LessonContent;
}

export const lessonService = new LessonService();
