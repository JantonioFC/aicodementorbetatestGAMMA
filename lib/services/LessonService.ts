
import { logger } from '../utils/logger';
import { geminiRouter } from '../ai/router/GeminiRouter';
import { AnalysisAnalysis } from '../ai/providers/BaseProvider';
import { buildLessonPromptMessages, LessonContext } from '../prompts/LessonPrompts';

// --- Interfaces de Dominio ---

export interface LessonRequest {
    topic: string;
    difficulty: string;
    userId?: string;
    language?: string;
    context?: LessonContext; // Contexto específico para el prompt
    injectedContext?: string[]; // Contexto RAG inyectado
    metadata?: Record<string, any>;
}

export interface LessonContent {
    id: string;
    title: string;
    content: string; // Markdown generated by AI
    difficulty: string;
    language: string;
    quiz?: any[]; // Quizzes generated by AI
    exercises?: any[]; // Interactive exercises
    metadata: {
        engine: string;
        model: string;
        generated_at: string;
        tokens_used?: number;
        latency?: number;
        [key: string]: any;
    };
    raw_analysis?: AnalysisAnalysis; // Optional detailed analysis
}

// --- Pipe Utility ---
const pipe = <T>(...fns: Array<(arg: T) => Promise<T>>) => (x: T) => fns.reduce((v, f) => v.then(f), Promise.resolve(x));

export class LessonService {

    /**
     * Genera una lección educativa utilizando IA.
     * Conecta directamente con GeminiRouter para orquestación de modelos.
     */
    async generateLesson(params: LessonRequest): Promise<LessonContent> {
        logger.info(`[LessonService] Pipeline Started: ${params.topic}`);

        // Execute Functional Pipeline
        // Note: The intermediate type flows through these functions
        // We cast the initial params to 'any' to start the chain, or define a specific PipelineContext type
        // For simplicity in migration, we'll use a specific context type.

        const initialContext: PipelineContext = {
            request: params,
            timestamp: Date.now()
        };

        const result = await pipe(
            this._validateContext,
            this._generateAIContent,
            this._structureOutput
        )(initialContext);

        if (!result.lesson) {
            throw new Error('Failed to generate lesson content');
        }

        return result.lesson;
    }

    // --- Functional Stages ---

    private _validateContext = async (ctx: PipelineContext): Promise<PipelineContext> => {
        if (!ctx.request.topic) throw new Error('Topic is required');
        return ctx;
    }

    private _generateAIContent = async (ctx: PipelineContext): Promise<PipelineContext> => {
        const { topic, difficulty, language, injectedContext, context } = ctx.request;
        const lang = language || 'es';

        // 1. Construir Prompts
        const lessonContext: LessonContext = {
            tematica_semanal: topic,
            concepto_del_dia: `Nivel ${difficulty}`,
            texto_del_pomodoro: injectedContext ? injectedContext.join('\n\n') : undefined,
            ...context // Merge extra context
        };

        const rawMessages = buildLessonPromptMessages(lessonContext);

        // Map to AnalysisRequest format
        let systemPrompt = '';
        const mappedMessages: Array<{ role: 'user' | 'model'; content: string }> = [];

        for (const msg of rawMessages) {
            if (msg.role === 'system') {
                systemPrompt += msg.content + '\n';
            } else {
                mappedMessages.push({
                    role: msg.role === 'assistant' ? 'model' : 'user',
                    content: msg.content
                });
            }
        }

        // 2. Llamar a GeminiRouter
        try {
            const response = await geminiRouter.analyze({
                code: '', // No code for lesson generation
                language: lang,
                phase: 'fase-1', // Default educational phase
                systemPrompt: systemPrompt.trim(),
                messages: mappedMessages,
                analysisType: 'lesson_generation'
            });

            return {
                ...ctx,
                aiResponse: response
            };

        } catch (error: any) {
            logger.error(`[LessonService] AI Generation failed: ${error.message}`);
            throw error;
        }
    }

    private _structureOutput = async (ctx: PipelineContext): Promise<PipelineContext> => {
        if (!ctx.aiResponse) {
            throw new Error('No AI response available to structure');
        }

        const { request, aiResponse, timestamp } = ctx;
        const analysis = aiResponse.analysis;

        // El contenido principal suele venir en 'feedback' o 'content' dependiendo del prompt/modelo
        // Ajustamos según lo que retorna GeminiProvider (feedback, strengths, etc)
        // O si el prompt pide JSON específico.
        // Por ahora, asumimos que 'feedback' contiene el cuerpo principal de la lección
        // Si el prompt de lección no fuerza JSON estricto de AnalysisAnalysis, esto podría variar.
        // Asumiendo que GeminiProvider siempre intenta parsear a AnalysisAnalysis.

        const contentBody = analysis.feedback || analysis['content'] || JSON.stringify(analysis);
        const quiz = analysis.quiz || analysis['quiz_questions'] || [];
        const exercises = analysis.exercises || analysis['practical_exercises'] || [];

        const lesson: LessonContent = {
            id: `gen-${timestamp}`,
            title: `Lección experta: ${request.topic}`,
            content: contentBody,
            difficulty: request.difficulty,
            language: request.language || 'es',
            quiz,
            exercises,
            metadata: {
                engine: 'v4-gemini-router',
                model: aiResponse.metadata.model,
                generated_at: new Date().toISOString(),
                tokens_used: aiResponse.metadata.tokensUsed,
                latency: aiResponse.metadata.latency,
                ...request.metadata
            },
            raw_analysis: analysis
        };

        return {
            ...ctx,
            lesson
        };
    }
}

// Internal Interface for the Pipeline Flow
interface PipelineContext {
    request: LessonRequest;
    timestamp: number;
    aiResponse?: any; // Typed as any from GeminiRouter response for flexibility or specific AnalysisResponse
    lesson?: LessonContent;
}

export const lessonService = new LessonService();
